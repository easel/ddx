package config

import (
	"os"
	"path/filepath"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// TestGetLibraryPath_ConfigFile tests library path resolution from config file
func TestGetLibraryPath_ConfigFile(t *testing.T) {
	tests := []struct {
		name           string
		setup          func(t *testing.T) (cleanup func())
		overridePath   string
		expectedResult func(t *testing.T) string
		expectError    bool
	}{
		{
			name: "config_file_library_path_relative",
			setup: func(t *testing.T) func() {
				// Create test directory structure
				testDir := t.TempDir()
				origWd, _ := os.Getwd()
				require.NoError(t, os.Chdir(testDir))

				// Create library directory
				libDir := filepath.Join(testDir, "my-library")
				require.NoError(t, os.MkdirAll(libDir, 0755))

				// Create .ddx.yml with library_path
				configContent := `version: "2.0"
library_path: ./my-library
repository:
  url: https://github.com/easel/ddx
  branch: main
  path: .ddx/`
				require.NoError(t, os.WriteFile(".ddx.yml", []byte(configContent), 0644))

				return func() {
					os.Chdir(origWd)
				}
			},
			expectedResult: func(t *testing.T) string {
				wd, _ := os.Getwd()
				return filepath.Join(wd, "my-library")
			},
			expectError: false,
		},
		{
			name: "config_file_library_path_absolute",
			setup: func(t *testing.T) func() {
				// Create test directory structure
				testDir := t.TempDir()
				origWd, _ := os.Getwd()
				require.NoError(t, os.Chdir(testDir))

				// Create library directory at absolute path
				libDir := filepath.Join(testDir, "absolute-library")
				require.NoError(t, os.MkdirAll(libDir, 0755))

				// Create .ddx.yml with absolute library_path
				configContent := `version: "2.0"
library_path: ` + libDir + `
repository:
  url: https://github.com/easel/ddx
  branch: main
  path: .ddx/`
				require.NoError(t, os.WriteFile(".ddx.yml", []byte(configContent), 0644))

				return func() {
					os.Chdir(origWd)
				}
			},
			expectedResult: func(t *testing.T) string {
				wd, _ := os.Getwd()
				return filepath.Join(wd, "absolute-library")
			},
			expectError: false,
		},
		{
			name: "config_file_library_path_nonexistent",
			setup: func(t *testing.T) func() {
				// Create test directory structure
				testDir := t.TempDir()
				origWd, _ := os.Getwd()
				require.NoError(t, os.Chdir(testDir))

				// Create .ddx.yml with nonexistent library_path
				configContent := `version: "2.0"
library_path: ./nonexistent-library
repository:
  url: https://github.com/easel/ddx
  branch: main
  path: .ddx/`
				require.NoError(t, os.WriteFile(".ddx.yml", []byte(configContent), 0644))

				return func() {
					os.Chdir(origWd)
				}
			},
			expectError: true,
		},
		{
			name: "env_var_overrides_config_file",
			setup: func(t *testing.T) func() {
				// Create test directory structure
				testDir := t.TempDir()
				origWd, _ := os.Getwd()
				require.NoError(t, os.Chdir(testDir))

				// Create both library directories
				configLibDir := filepath.Join(testDir, "config-library")
				envLibDir := filepath.Join(testDir, "env-library")
				require.NoError(t, os.MkdirAll(configLibDir, 0755))
				require.NoError(t, os.MkdirAll(envLibDir, 0755))

				// Create .ddx.yml with library_path
				configContent := `version: "2.0"
library_path: ./config-library
repository:
  url: https://github.com/easel/ddx
  branch: main
  path: .ddx/`
				require.NoError(t, os.WriteFile(".ddx.yml", []byte(configContent), 0644))

				// Set environment variable (higher priority)
				t.Setenv("DDX_LIBRARY_BASE_PATH", envLibDir)

				return func() {
					os.Chdir(origWd)
				}
			},
			expectedResult: func(t *testing.T) string {
				wd, _ := os.Getwd()
				return filepath.Join(wd, "env-library")
			},
			expectError: false,
		},
		{
			name: "flag_overrides_config_file",
			setup: func(t *testing.T) func() {
				// Create test directory structure
				testDir := t.TempDir()
				origWd, _ := os.Getwd()
				require.NoError(t, os.Chdir(testDir))

				// Create both library directories
				configLibDir := filepath.Join(testDir, "config-library")
				flagLibDir := filepath.Join(testDir, "flag-library")
				require.NoError(t, os.MkdirAll(configLibDir, 0755))
				require.NoError(t, os.MkdirAll(flagLibDir, 0755))

				// Create .ddx.yml with library_path
				configContent := `version: "2.0"
library_path: ./config-library
repository:
  url: https://github.com/easel/ddx
  branch: main
  path: .ddx/`
				require.NoError(t, os.WriteFile(".ddx.yml", []byte(configContent), 0644))

				return func() {
					os.Chdir(origWd)
				}
			},
			overridePath: "./flag-library",
			expectedResult: func(t *testing.T) string {
				wd, _ := os.Getwd()
				return filepath.Join(wd, "flag-library")
			},
			expectError: false,
		},
		{
			name: "config_in_parent_directory",
			setup: func(t *testing.T) func() {
				// Create test directory structure
				testDir := t.TempDir()
				origWd, _ := os.Getwd()

				// Create library directory
				libDir := filepath.Join(testDir, "parent-library")
				require.NoError(t, os.MkdirAll(libDir, 0755))

				// Create .ddx.yml in parent with library_path
				configContent := `version: "2.0"
library_path: ./parent-library
repository:
  url: https://github.com/easel/ddx
  branch: main
  path: .ddx/`
				require.NoError(t, os.WriteFile(filepath.Join(testDir, ".ddx.yml"), []byte(configContent), 0644))

				// Create subdirectory and change to it
				subDir := filepath.Join(testDir, "subproject")
				require.NoError(t, os.MkdirAll(subDir, 0755))
				require.NoError(t, os.Chdir(subDir))

				return func() {
					os.Chdir(origWd)
				}
			},
			expectedResult: func(t *testing.T) string {
				// The library path is resolved relative to where the config file is
				parent, _ := filepath.Abs("..")
				return filepath.Join(parent, "parent-library")
			},
			expectError: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			cleanup := tt.setup(t)
			defer cleanup()

			wd, _ := os.Getwd()
			result, err := GetLibraryPathWithWorkingDir(tt.overridePath, wd)

			if tt.expectError {
				assert.Error(t, err)
			} else {
				require.NoError(t, err)
				expected := tt.expectedResult(t)
				assert.Equal(t, expected, result)
			}
		})
	}
}

// TestGetLibraryPath_DevelopmentMode tests library path resolution in DDx development
func TestGetLibraryPath_DevelopmentMode(t *testing.T) {
	tests := []struct {
		name           string
		setup          func(t *testing.T) (cleanup func())
		expectedResult func(t *testing.T) string
		expectError    bool
	}{
		{
			name: "development_mode_git_repo_with_library",
			setup: func(t *testing.T) func() {
				// Create test directory structure that mimics DDx development
				testDir := t.TempDir()
				origWd, _ := os.Getwd()
				require.NoError(t, os.Chdir(testDir))

				// Create git repository
				require.NoError(t, os.MkdirAll(".git", 0755))

				// Create cli/main.go (identifies DDx repository)
				require.NoError(t, os.MkdirAll("cli", 0755))
				require.NoError(t, os.WriteFile("cli/main.go", []byte("package main"), 0644))

				// Create library directory with personas
				require.NoError(t, os.MkdirAll("library/personas", 0755))

				// Don't create .ddx.yml to ensure we're testing development mode

				return func() {
					os.Chdir(origWd)
				}
			},
			expectedResult: func(t *testing.T) string {
				wd, _ := os.Getwd()
				return filepath.Join(wd, "library")
			},
			expectError: false,
		},
		{
			name: "git_repo_without_cli_main_not_development",
			setup: func(t *testing.T) func() {
				// Create test directory with git but not DDx development
				testDir := t.TempDir()
				origWd, _ := os.Getwd()
				require.NoError(t, os.Chdir(testDir))

				// Create git repository
				require.NoError(t, os.MkdirAll(".git", 0755))

				// Create library directory but NO cli/main.go
				require.NoError(t, os.MkdirAll("library", 0755))

				// Should fall back to global ~/.ddx/library

				return func() {
					os.Chdir(origWd)
				}
			},
			expectedResult: func(t *testing.T) string {
				// Since no .ddx.yml exists and we're not in DDx development mode,
				// should fall back to global library
				homeDir, _ := os.UserHomeDir()
				return filepath.Join(homeDir, ".ddx", "library")
			},
			expectError: false,
		},
		{
			name: "development_mode_from_subdirectory",
			setup: func(t *testing.T) func() {
				// Create test directory structure
				testDir := t.TempDir()
				origWd, _ := os.Getwd()

				// Create DDx development structure
				require.NoError(t, os.MkdirAll(filepath.Join(testDir, ".git"), 0755))
				require.NoError(t, os.MkdirAll(filepath.Join(testDir, "cli"), 0755))
				require.NoError(t, os.WriteFile(filepath.Join(testDir, "cli", "main.go"), []byte("package main"), 0644))
				require.NoError(t, os.MkdirAll(filepath.Join(testDir, "library", "personas"), 0755))

				// Create a subdirectory and change to it
				subDir := filepath.Join(testDir, "cli", "internal", "config")
				require.NoError(t, os.MkdirAll(subDir, 0755))
				require.NoError(t, os.Chdir(subDir))

				return func() {
					os.Chdir(origWd)
				}
			},
			expectedResult: func(t *testing.T) string {
				// Should find the git root and return library from there
				// Go up 3 levels from cli/internal/config
				gitRoot, _ := filepath.Abs("../../..")
				return filepath.Join(gitRoot, "library")
			},
			expectError: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			cleanup := tt.setup(t)
			defer cleanup()

			// Clear any environment variables that might interfere
			t.Setenv("DDX_LIBRARY_BASE_PATH", "")

			wd, _ := os.Getwd()
			result, err := GetLibraryPathWithWorkingDir("", wd)

			if tt.expectError {
				assert.Error(t, err)
			} else {
				require.NoError(t, err)
				expected := tt.expectedResult(t)
				assert.Equal(t, expected, result)
			}
		})
	}
}

// TestGetLibraryPath_PriorityOrder verifies the complete priority order
func TestGetLibraryPath_PriorityOrder(t *testing.T) {
	// This test verifies the documented priority order:
	// 1. Command flag (overridePath)
	// 2. Environment variable (DDX_LIBRARY_BASE_PATH)
	// 3. Config file (library_path in .ddx.yml)
	// 4. Git repo detection (DDx development)
	// 5. Project library (.ddx/library/)
	// 6. Global fallback (~/.ddx/library/)

	testDir := t.TempDir()
	origWd, _ := os.Getwd()
	defer os.Chdir(origWd)
	require.NoError(t, os.Chdir(testDir))

	// Create all possible library locations
	flagLib := filepath.Join(testDir, "flag-lib")
	envLib := filepath.Join(testDir, "env-lib")
	configLib := filepath.Join(testDir, "config-lib")
	projectLib := filepath.Join(testDir, ".ddx", "library")

	require.NoError(t, os.MkdirAll(flagLib, 0755))
	require.NoError(t, os.MkdirAll(envLib, 0755))
	require.NoError(t, os.MkdirAll(configLib, 0755))
	require.NoError(t, os.MkdirAll(projectLib, 0755))

	// Create config file with library_path
	configContent := `version: "2.0"
library_path: ./config-lib
repository:
  url: https://github.com/easel/ddx
  branch: main
  path: .ddx/`
	require.NoError(t, os.WriteFile(".ddx.yml", []byte(configContent), 0644))

	// Test 1: Flag should override everything
	wd, _ := os.Getwd()
	result, err := GetLibraryPathWithWorkingDir(flagLib, wd)
	require.NoError(t, err)
	assert.Equal(t, flagLib, result, "Flag should have highest priority")

	// Test 2: Env var should override config (when no flag)
	t.Setenv("DDX_LIBRARY_BASE_PATH", envLib)
	result, err = GetLibraryPathWithWorkingDir("", wd)
	require.NoError(t, err)
	assert.Equal(t, envLib, result, "Env var should override config")

	// Test 3: Config should be used when no flag or env
	os.Unsetenv("DDX_LIBRARY_BASE_PATH")
	t.Setenv("DDX_LIBRARY_BASE_PATH", "") // Clear for test
	result, err = GetLibraryPathWithWorkingDir("", wd)
	require.NoError(t, err)
	expected := filepath.Join(testDir, "config-lib")
	assert.Equal(t, expected, result, "Config library_path should be used")
}

// TestConfigLibraryPath_Validation tests validation of library_path in config
func TestConfigLibraryPath_Validation(t *testing.T) {
	tests := []struct {
		name        string
		libraryPath string
		setup       func(t *testing.T, path string)
		expectError bool
		errorMsg    string
	}{
		{
			name:        "valid_relative_path",
			libraryPath: "./library",
			setup: func(t *testing.T, path string) {
				require.NoError(t, os.MkdirAll(path, 0755))
			},
			expectError: false,
		},
		{
			name:        "valid_absolute_path",
			libraryPath: "/tmp/test-library",
			setup: func(t *testing.T, path string) {
				require.NoError(t, os.MkdirAll(path, 0755))
			},
			expectError: false,
		},
		{
			name:        "path_traversal_attempt",
			libraryPath: "../../../etc/passwd",
			setup:       func(t *testing.T, path string) {},
			expectError: true,
			errorMsg:    "does not exist", // Changed expectation - path validation happens when checking existence
		},
		{
			name:        "empty_path",
			libraryPath: "",
			setup:       func(t *testing.T, path string) {},
			expectError: false, // Empty is valid, means not configured
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			testDir := t.TempDir()
			origWd, _ := os.Getwd()
			defer os.Chdir(origWd)
			require.NoError(t, os.Chdir(testDir))

			// Adjust path if relative
			actualPath := tt.libraryPath
			if tt.libraryPath != "" && !filepath.IsAbs(tt.libraryPath) {
				actualPath = filepath.Join(testDir, tt.libraryPath)
			}

			tt.setup(t, actualPath)

			// Create config with library_path
			cfg := &Config{
				Version:     "2.0",
				LibraryPath: tt.libraryPath,
				Repository: Repository{
					URL:    "https://github.com/easel/ddx",
					Branch: "main",
					Path:   ".ddx/",
				},
			}

			// Save and reload to test full cycle
			require.NoError(t, SaveLocal(cfg))

			loadedCfg, err := LoadLocal()
			if tt.expectError {
				if err == nil {
					// Validation might happen during library path resolution
					wd, _ := os.Getwd()
					_, err = GetLibraryPathWithWorkingDir("", wd)
				}
				assert.Error(t, err)
				if err != nil && tt.errorMsg != "" {
					assert.Contains(t, err.Error(), tt.errorMsg)
				}
			} else {
				require.NoError(t, err)
				if tt.libraryPath != "" {
					assert.Equal(t, tt.libraryPath, loadedCfg.LibraryPath)
				}
			}
		})
	}
}
