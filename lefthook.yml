# Lefthook configuration for DDx project
# Fast, cross-platform git hooks
# https://github.com/evilmartians/lefthook

# Configuration
colors: true
no_tty: false
assertion: false

# Reusable command groups
command_groups:
  go_checks: &go_checks
    root: "cli/"  # Go module root
    tags: [go, backend]

  security_checks: &security_checks
    tags: [security]

  formatting_checks: &formatting_checks
    tags: [format, style]

# ====================
# Pre-commit hooks - Fast checks on staged files
# ====================
pre-commit:
  parallel: true

  commands:
    # Conflict detection using grep on staged files only
    conflicts:
      name: "Check merge conflicts"
      run: 'grep -E "^<<<<<<<[ \t]|^=======$|^>>>>>>>[ \t]|^\|\|\|\|\|\|\|[ \t]" {staged_files} 2>/dev/null && exit 1 || exit 0'
      glob: "*"
      exclude: "lefthook.yml"
      fail_text: "Merge conflict markers found. Resolve conflicts before committing."

    # Debug statements - using ripgrep if available, fallback to grep
    # Note: Disabled because CLI applications legitimately use fmt.Print for output
    # debug-go:
    #   name: "Debug statements (Go)"
    #   glob: "*.go"
    #   exclude: "*_test.go"
    #   run: |
    #     if command -v rg >/dev/null 2>&1; then
    #       rg -q "(fmt\.Print|println|spew\.Dump|pprof\.|debug\.Print)" {staged_files} && exit 1 || exit 0
    #     else
    #       grep -E "(fmt\.Print|println|spew\.Dump|pprof\.|debug\.Print)" {staged_files} 2>/dev/null && exit 1 || exit 0
    #     fi
    #   fail_text: "Debug statements found in Go files"

    debug-js:
      name: "Debug statements (JS/TS)"
      glob: "*.{js,jsx,ts,tsx}"
      run: |
        if command -v rg >/dev/null 2>&1; then
          rg -q "(console\.(log|debug|info)|debugger)" {staged_files} && exit 1 || exit 0
        else
          grep -E "(console\.(log|debug|info)|debugger)" {staged_files} 2>/dev/null && exit 1 || exit 0
        fi
      fail_text: "Debug statements found in JS/TS files"

    debug-python:
      name: "Debug statements (Python)"
      glob: "*.py"
      run: |
        if command -v rg >/dev/null 2>&1; then
          rg -q "(print\(|pdb\.set_trace|breakpoint\(\)|import pdb)" {staged_files} && exit 1 || exit 0
        else
          grep -E "(print\(|pdb\.set_trace|breakpoint\(\)|import pdb)" {staged_files} 2>/dev/null && exit 1 || exit 0
        fi
      fail_text: "Debug statements found in Python files"

    # Go formatting - native gofmt
    go-fmt:
      <<: *go_checks
      name: "Go Format"
      glob: "cli/**/*.go"
      run: |
        unformatted=$(gofmt -l {staged_files})
        if [ -n "$unformatted" ]; then
          echo "Files need formatting: $unformatted"
          echo "Run: gofmt -w <files>"
          exit 1
        fi
      skip:
        - merge
        - rebase

    # Go linting - golangci-lint required
    go-lint:
      <<: *go_checks
      name: "Go Lint"
      glob: "cli/**/*.go"
      run: |
        if ! command -v golangci-lint >/dev/null 2>&1; then
          echo "❌ golangci-lint is required but not installed"
          echo "Run: scripts/dev-setup.sh"
          exit 1
        fi
        # Run on packages containing staged files, not individual files
        packages=$(echo {staged_files} | xargs -n1 dirname | sort -u | sed 's|^cli/|./|')
        for pkg in $packages; do
          golangci-lint run --timeout=60s --new-from-rev=HEAD~1 "$pkg"
        done
      skip:
        - merge
        - rebase

    # Go build - only for changed packages
    go-build:
      <<: *go_checks
      name: "Go Build"
      glob: "cli/**/*.go"
      run: 'go build -v ./...'
      skip:
        - merge
        - rebase

    # Go tests - targeted testing
    go-test:
      <<: *go_checks
      name: "Go Tests"
      glob: "cli/**/*.go"
      run: |
        packages=$(echo {staged_files} | xargs -n1 dirname | sort -u | sed 's|^cli/||')
        for pkg in $packages; do
          if ls "$pkg"/*_test.go >/dev/null 2>&1; then
            go test -short -race "./$pkg"
          fi
        done
      skip:
        - merge
        - rebase
      env:
        SKIP_INTEGRATION_TESTS: "true"

    # Secrets scanning - prefer gitleaks when available
    secrets:
      <<: *security_checks
      name: "Scan for secrets"
      run: |
        if command -v gitleaks >/dev/null 2>&1; then
          gitleaks protect --staged --verbose --redact
        else
          # Fallback to pattern matching
          patterns='(api[_-]?key|apikey|secret|token|password|passwd|pwd|auth|credential|private[_-]?key).*=.*["'"'"'][A-Za-z0-9+/]{20,}'
          if grep -E "$patterns" {staged_files} 2>/dev/null; then
            echo "Potential secrets detected"
            exit 1
          fi

          # AWS keys
          if grep -E 'AKIA[0-9A-Z]{16}' {staged_files} 2>/dev/null; then
            echo "AWS key pattern detected"
            exit 1
          fi

          # GitHub tokens
          if grep -E 'ghp_[a-zA-Z0-9]{36}' {staged_files} 2>/dev/null; then
            echo "GitHub token pattern detected"
            exit 1
          fi
        fi
      exclude:
        - "*.md"
        - "go.sum"
        - "package-lock.json"
        - "*_test.go"
      fail_text: "Secrets detected! Remove them or add to .gitleaks.toml if false positive"

    # Binary and large file check
    large-files:
      name: "Check file sizes"
      run: |
        for file in {staged_files}; do
          size=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null || echo 0)
          if [ "$size" -gt 5242880 ]; then
            echo "Large file detected: $file ($(($size / 1048576))MB)"
            exit 1
          fi
        done
      exclude:
        - "*.png"
        - "*.jpg"
        - "*.jpeg"
        - "*.gif"
        - "*.svg"
        - "*.ico"
        - "*.pdf"
        - "*.woff"
        - "*.woff2"
        - "*.ttf"
        - "*.eot"
      fail_text: "Large files detected. Use Git LFS for files over 5MB"

    # DDx validation - only when relevant files change
    ddx-validate:
      name: "Validate DDx"
      run: |
        # Only run if DDx files are staged
        if ! git diff --cached --name-only | grep -qE '(\.ddx\.yml|templates/|patterns/|prompts/)'; then
          exit 0
        fi

        # Check for DDx command availability
        if command -v ddx >/dev/null 2>&1; then
          ddx doctor >/dev/null 2>&1
        elif [ -x "./cli/ddx" ]; then
          ./cli/ddx doctor >/dev/null 2>&1
        fi
      fail_text: "DDx validation failed. Run 'ddx doctor' for details"

# ====================
# CI/CD - Full validation (all files)
# ====================
ci:
  parallel: true

  commands:
    # Full conflict check
    conflicts-all:
      name: "Check all merge conflicts"
      run: |
        # Check for actual merge conflict markers (exactly 7 characters followed by space or newline)
        conflicts=$(find . -type f ! -path "./.git/*" ! -path "./cli/.git/*" ! -name "lefthook.yml" \
          -exec grep -l "^<<<<<<<[ \t]\|^=======\$\|^>>>>>>>[ \t]\|^||||||[ \t]" {} \; 2>/dev/null | head -1)
        if [ -n "$conflicts" ]; then
          echo "Merge conflict markers found in: $conflicts"
          exit 1
        fi

    # Full secrets scan
    secrets-all:
      <<: *security_checks
      name: "Full secrets scan"
      run: |
        if command -v gitleaks >/dev/null 2>&1; then
          gitleaks detect --verbose --redact
        else
          echo "Consider installing gitleaks for comprehensive secret scanning"
        fi

    # Go full test suite
    go-test-all:
      <<: *go_checks
      name: "Full Go test suite"
      root: "cli/"
      run: 'go test -race -cover ./...'

    # Go formatting check all files
    go-fmt-all:
      <<: *go_checks
      name: "Check all Go formatting"
      root: "cli/"
      run: |
        unformatted=$(gofmt -l .)
        if [ -n "$unformatted" ]; then
          echo "Unformatted files: $unformatted"
          exit 1
        fi

    # Go lint all files
    go-lint-all:
      <<: *go_checks
      name: "Lint all Go files"
      root: "cli/"
      run: |
        if ! command -v golangci-lint >/dev/null 2>&1; then
          echo "❌ golangci-lint is required but not installed"
          echo "Run: scripts/dev-setup.sh"
          exit 1
        fi
        golangci-lint run --timeout=5m

    # Go build all targets
    go-build-all:
      <<: *go_checks
      name: "Build all targets"
      root: "cli/"
      run: 'go build -v ./...'

    # YAML validation
    yaml-validate:
      name: "Validate YAML files"
      glob: "**/*.{yml,yaml}"
      run: |
        if command -v yq >/dev/null 2>&1; then
          for file in {all_files}; do
            yq eval . "$file" >/dev/null || exit 1
          done
        fi

# ====================
# Pre-push hooks - Extended validation
# ====================
pre-push:
  parallel: false

  commands:
    # Run full test suite before push
    full-tests:
      name: "Full test suite"
      root: "cli/"
      run: 'go test -race -cover ./...'
      tags: [go, test]

    # Ensure no debug statements in any file
    no-debug:
      name: "No debug statements"
      run: |
        if command -v rg >/dev/null 2>&1; then
          ! rg -q "(console\.log|fmt\.Print(?!ln)|pdb\.set_trace|debugger)" --type-add 'code:*.{go,js,jsx,ts,tsx,py}' -t code
        fi

# Skip configuration
# Usage: LEFTHOOK_EXCLUDE=go-test,secrets git commit
# Or: LEFTHOOK=0 git commit (skip all hooks)

# Install hooks: lefthook install
# Run manually: lefthook run pre-commit
# Run CI checks: lefthook run ci